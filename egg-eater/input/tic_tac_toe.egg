type pair = (Int * Int)
type triple = (Int * pair)
type pairlist = (pair * pairlist)
type triplelist = (triple * triplelist)

def link(first, rest):
  (first, rest)
and
def make_row():
	(0, 0, 0)
and
def make_board():
	(make_row(), make_row(), make_row())
and 
def print_board((row1, row2, row3)):
	print(row1);
	print(row2);
	print(row3);
	0
and
def set_row_val(row : (Int * Int * Int), y, val):
	if y == 0: row[0 of 3 := val]
	else:
		if y == 1: row[1 of 3 := val]
		else: row[2 of 3 := val]
and
def get_row_val(row : (Int * Int * Int), y):
	if y == 0: row[0 of 3]
	else:
		if y == 1: row[1 of 3]
		else: row[2 of 3]
and
def get_row((row1, row2, row3), x):
	if x == 0: row1
	else:
		if x == 1: row2
		else: row3
and
def get_board_val(board, x, y):
	let row = get_row(board, x) in
		get_row_val(row, y)
and
def set_board((row1, row2, row3), x, y, val):
	if x == 0: set_row_val(row1, y, val)
	else:
		if x == 1: set_row_val(row2, y, val)
		else: set_row_val(row3, y, val)
and 
def set_diag(diag : (Int), x, y, player):
  	if x == y: 
  		diag[0 of 1 := (diag[0 of 1] + player)]
  	else: diag
and
def set_adiag(adiag : (Int), x, y, player):
  	if x == (2 - y): 
  		adiag[0 of 1 := (adiag[0 of 1] + player)]
  	else: adiag
and
def is_valid_pos(board, x, y):
	if (x < 0) || (x > 2) || (y < 0) || (y > 2): false
	else: get_board_val(board, x, y) == 0
and
def make_move(board, counters, x, y, player):
    let (row_cts, col_cts, diag_ct, adiag_ct) = counters in
		set_board(board, x, y, (if player == -1 : 2 else: 1));
		set_row_val(row_cts, x, get_row_val(row_cts, x) + player);
		set_row_val(col_cts, y, get_row_val(col_cts, y) + player);
		set_diag(diag_ct, x, y, player);
		set_adiag(adiag_ct, x, y, player);
		0		
and
def reverse_move(board, counters, x, y, player): 
    let (row_cts, col_cts, diag_ct, adiag_ct) = counters in
		set_board(board, x, y, 0);
		set_row_val(row_cts, x, get_row_val(row_cts, x) - player);
		set_row_val(col_cts, y, get_row_val(col_cts, y) - player);
		set_diag(diag_ct, x, y, 0 - player);
		set_adiag(adiag_ct, x, y, 0 - player);
		0		
and
def get_user_input():
  input()
and
def get_user_move(board):
  let x = get_user_input() in
  let y = get_user_input() in 
  	if is_valid_pos(board, x, y): (x, y)
  	else: get_user_move(board)
and
def get_max_move(l : triplelist) -> triple:
	if l == (nil : triplelist): (-2,(-1,-1))
    else: 
    	let pair1 = l[0 of 2] in
    	let pair2 = get_max_move(l[1 of 2]) in
    		let (r1, m1) = pair1, (r2, m2) = pair2 in
    			if (r1 > r2): pair1
    			else: pair2
and
def check_winner((row_cts, col_cts, diag_ct : (Int), adiag_ct : (Int)), x, y, player):
	if (get_row_val(row_cts, x) == (3 * player)) || 
	   (get_row_val(col_cts, y) == (3 * player)) || 
	   (diag_ct[0 of 1] == (3 * player)) || 
	   (adiag_ct[0 of 1] == (3 * player)): player
	else: 0
and
def flip_player(player):
	if player == 1: -1 else: 1
and
def rate_positions(l : pairlist, board, counters, player, depth) -> triplelist :
    if depth == 0: (nil:triplelist)
    else:
		if l == (nil: pairlist) : (nil:triplelist)
	    else:
	    	let (x, y) = l[0 of 2] in
	    	let rate = rate_pos(board, counters, (x, y), player, depth) in
	    	let rated = (rate, (x, y)) in
	    		link(rated, rate_positions(l[1 of 2], board, counters, player, depth))
and
def get_best_move(board, counters, player, depth) -> triple:
	if (depth == 0): (0, (-1, -1))
    else:
		let candidates : pairlist = link((0,0),link((0,1),link((0,2),link((1,0),link((1,1),link((1,2),link((2,0),link((2,1),link((2,2), (nil: pairlist)))))))))) in
		let rated : triplelist = rate_positions(candidates, board, counters, player, depth) in
		let rated_move = get_max_move(rated) in
			rated_move
and
def rate_pos(board, counters, (x, y), player, depth) -> Int:
	if !(is_valid_pos(board, x, y)): -2
	else:
		make_move(board, counters, x, y, player);
		if (check_winner(counters, x, y, player) == player): 
			reverse_move(board, counters, x, y, player); 
			1
	    else:
	    	let opponent = flip_player(player) in
	    	let rated_opponent_move = get_best_move(board, counters, opponent, depth - 1) in
	    		reverse_move(board, counters, x, y, player); 
	    		0 - rated_opponent_move[0 of 2]
and
def get_computer_move(board, counters, player): 
	let max_depth = 1 in
	let (_, best_move) = get_best_move(board, counters, player, max_depth) in
		best_move
and
def init_game():
	let empty_board = make_board() in
	print_board(empty_board);
	let counters = (make_row(), make_row(), (0,), (0,)) in
		play_game(empty_board, 0, 1, counters)
and
def play_game(board, step, player, counters):
  if step == 10: 0
  else: 
    let move = (if player == 1: get_user_move(board) 
                else: get_computer_move(board, counters, player)) in
    let (x, y) = move in
  		make_move(board, counters, x, y, player);
  		print_board(board);
  		print((if player == -1 : 2 else: 1));
  		print(move);
  		let winner = check_winner(counters, x, y, player) in
  		  if winner == 0:
  	    	let next_player = flip_player(player) in
  			  play_game(board, step + 1, next_player, counters)
  		  else:
  		  	if winner == -1 : 2 else: 1

init_game()
